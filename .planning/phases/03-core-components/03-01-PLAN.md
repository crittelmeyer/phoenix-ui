---
phase: 03-core-components
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/ui/package.json
  - packages/ui/src/lib/utils.ts
  - packages/ui/src/components/button.tsx
  - packages/ui/src/components/input.tsx
  - packages/ui/src/components/textarea.tsx
autonomous: true

must_haves:
  truths:
    - 'cn() merges conflicting Tailwind classes correctly (last wins)'
    - 'Button renders with 6 variants and 4 sizes via CVA with TypeScript autocomplete'
    - 'Button supports asChild polymorphism via Radix Slot'
    - 'Input accepts forwarded ref and renders with semantic tokens'
    - 'Textarea supports autoResize prop that grows/shrinks with content'
  artifacts:
    - path: 'packages/ui/src/lib/utils.ts'
      provides: 'cn() utility function'
      exports: ['cn']
    - path: 'packages/ui/src/components/button.tsx'
      provides: 'Button component with CVA variants'
      exports: ['Button', 'buttonVariants']
    - path: 'packages/ui/src/components/input.tsx'
      provides: 'Input component with forwarded ref'
      exports: ['Input']
    - path: 'packages/ui/src/components/textarea.tsx'
      provides: 'Textarea component with autoResize'
      exports: ['Textarea']
  key_links:
    - from: 'packages/ui/src/components/button.tsx'
      to: 'packages/ui/src/lib/utils.ts'
      via: 'import { cn }'
      pattern: 'import.*cn.*from.*lib/utils'
    - from: 'packages/ui/src/components/button.tsx'
      to: '@radix-ui/react-slot'
      via: 'Slot for asChild'
      pattern: 'import.*Slot.*from.*@radix-ui/react-slot'
---

<objective>
Install core dependencies (CVA, clsx, tailwind-merge, Radix packages), create the cn() utility, and build the first 3 components: Button, Input, and Textarea.

Purpose: Establishes the component authoring pattern (cn + CVA + forwardRef + semantic tokens) that all subsequent components follow. Button is the most variant-heavy component and proves the CVA pattern works.

Output: 4 new source files (utils.ts, button.tsx, input.tsx, textarea.tsx) and updated package.json with all Phase 3 dependencies.
</objective>

<execution_context>
@/Users/chris/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-components/03-RESEARCH.md
@.planning/phases/03-core-components/03-CONTEXT.md
@apps/web/src/index.css
@packages/ui/package.json
@packages/ui/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create cn() utility</name>
  <files>
    packages/ui/package.json
    packages/ui/src/lib/utils.ts
  </files>
  <action>
    1. Install all Phase 3 dependencies into packages/ui (run from repo root):
       ```bash
       pnpm --filter @phoenix/ui add class-variance-authority clsx tailwind-merge @radix-ui/react-slot @radix-ui/react-select @radix-ui/react-dialog @radix-ui/react-checkbox @radix-ui/react-radio-group @radix-ui/react-label
       ```
       Install all Radix packages in a single command to avoid version mismatches (Pitfall #1 from research).

    2. Create `packages/ui/src/lib/utils.ts` with the cn() utility:
       ```typescript
       import { type ClassValue, clsx } from "clsx"
       import { twMerge } from "tailwind-merge"

       export function cn(...inputs: ClassValue[]) {
         return twMerge(clsx(inputs))
       }
       ```
       This is the standard shadcn/ui pattern. clsx handles conditionals, twMerge resolves Tailwind conflicts.

    3. Verify tailwind-merge version is 3.x (required for Tailwind v4 compatibility — Pitfall #6 from research):
       ```bash
       pnpm --filter @phoenix/ui ls tailwind-merge
       ```

  </action>
  <verify>
    - `pnpm --filter @phoenix/ui ls class-variance-authority clsx tailwind-merge @radix-ui/react-slot` shows all packages installed
    - `packages/ui/src/lib/utils.ts` exists and exports `cn`
    - tailwind-merge version is 3.x
    - `pnpm turbo run typecheck` passes
  </verify>
  <done>
    cn() utility exists at packages/ui/src/lib/utils.ts, all Phase 3 dependencies installed in packages/ui/package.json, typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Button, Input, and Textarea components</name>
  <files>
    packages/ui/src/components/button.tsx
    packages/ui/src/components/input.tsx
    packages/ui/src/components/textarea.tsx
  </files>
  <action>
    **Button component** (`packages/ui/src/components/button.tsx`):

    Follow shadcn/ui Button pattern exactly. Use CVA for variants:
    - Variants: default, destructive, outline, secondary, ghost, link (full shadcn set per CONTEXT.md)
    - Sizes: default (h-10 px-4 py-2), sm (h-9 px-3), lg (h-11 px-8), icon (h-10 w-10)
    - Base classes: inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium
    - Transitions: transition-colors (150ms ease per CONTEXT.md visual style)
    - Focus: focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 (ring offset style per CONTEXT.md)
    - Disabled: disabled:pointer-events-none disabled:opacity-50

    Use semantic token classes exclusively (bg-primary, text-primary-foreground, border-input, bg-background, bg-accent, text-accent-foreground, bg-secondary, text-secondary-foreground, bg-destructive, text-destructive-foreground).

    Implement asChild polymorphism via Radix Slot:
    ```typescript
    const Comp = asChild ? Slot : "button"
    ```

    Export both `Button` and `buttonVariants`.

    TypeScript: `React.forwardRef<HTMLButtonElement, ButtonProps>` where ButtonProps extends ButtonHTMLAttributes + VariantProps.

    **Input component** (`packages/ui/src/components/input.tsx`):

    Follow shadcn/ui Input pattern. Simple forwardRef wrapper around native `<input>`:
    - Styling: flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm
    - Ring offset: ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2
    - File input: file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground
    - Placeholder: placeholder:text-muted-foreground
    - Disabled: disabled:cursor-not-allowed disabled:opacity-50

    TypeScript: `React.forwardRef<HTMLInputElement, InputProps>` where InputProps extends InputHTMLAttributes.

    **Textarea component** (`packages/ui/src/components/textarea.tsx`):

    Follow shadcn/ui Textarea pattern with custom autoResize prop:
    - Base styling: flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm
    - Same ring/focus/placeholder/disabled styling as Input
    - Add `autoResize?: boolean` prop (default false)
    - When autoResize is true: add resize-none overflow-hidden classes, use useLayoutEffect to set height:auto then height:scrollHeight on value changes (reset-then-set pattern per research Pitfall #5)
    - Use internal ref merged with forwarded ref for autoResize measurement
    - Add onInput handler to trigger resize on typing (works for both controlled and uncontrolled)

    TypeScript: `React.forwardRef<HTMLTextAreaElement, TextareaProps>` where TextareaProps extends TextareaHTMLAttributes + { autoResize?: boolean }.

    All three components MUST:
    - Import cn from "../lib/utils"
    - Set displayName after forwardRef
    - Use semantic token classes only (no arbitrary hex values)
    - Spread {...props} on underlying element (Pitfall #4 from research)

  </action>
  <verify>
    - `pnpm turbo run typecheck` passes
    - `pnpm --filter @phoenix/ui run lint` passes (no inline styles, no arbitrary values)
    - Each file exports its component and sets displayName
    - Button exports both Button and buttonVariants
    - grep for "style=" in component files returns no results (semantic tokens only)
  </verify>
  <done>
    Button renders with 6 variants (default, destructive, outline, secondary, ghost, link) and 4 sizes (default, sm, lg, icon) via CVA. Input and Textarea accept forwarded refs. Textarea supports autoResize prop. All three use semantic token classes exclusively. TypeScript autocomplete works for all variant/size props.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo run typecheck` — all packages pass type checking
2. `pnpm --filter @phoenix/ui run lint` — no lint errors
3. All 4 files exist: lib/utils.ts, components/button.tsx, components/input.tsx, components/textarea.tsx
4. No hardcoded color values in any component file (grep -r "bg-\[#" or "text-\[#" returns nothing)
5. tailwind-merge version is 3.x (Tailwind v4 compatible)
</verification>

<success_criteria>

- COMP-01: cn() utility exists and combines clsx + tailwind-merge
- COMP-02: Button component has all 6 variants and 4 sizes via CVA with asChild support
- COMP-03: Input component with forwarded ref and semantic tokens
- COMP-04: Textarea component with autoResize option and semantic tokens
- All components use semantic token classes exclusively (COMP-15 partial)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-core-components/03-01-SUMMARY.md`
</output>
