---
phase: 06-ai-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/rules/ui-components.md
  - .claude/rules/token-authoring.md
  - .claude/rules/storybook-stories.md
autonomous: true

must_haves:
  truths:
    - 'ui-components.md loads only when editing files in packages/ui/src/components/'
    - 'token-authoring.md loads only when editing files in packages/tokens/src/tokens/'
    - 'storybook-stories.md loads only when editing files in apps/storybook/stories/'
    - 'Each rule file provides exact templates that produce correct results when followed mechanically'
    - 'Anti-patterns are documented alongside correct patterns with WHY explanations'
  artifacts:
    - path: '.claude/rules/ui-components.md'
      provides: 'Complete component authoring lifecycle template'
      contains: 'forwardRef'
    - path: '.claude/rules/token-authoring.md'
      provides: 'Token editing and creation constraints'
      contains: 'DTCG'
    - path: '.claude/rules/storybook-stories.md'
      provides: 'Story authoring template'
      contains: 'satisfies Meta'
  key_links:
    - from: '.claude/rules/ui-components.md'
      to: 'packages/ui/src/components/'
      via: 'paths frontmatter glob'
      pattern: 'packages/ui/src/components'
    - from: '.claude/rules/ui-components.md'
      to: 'packages/ui/src/index.ts'
      via: 'barrel export update instruction'
      pattern: 'index.ts'
---

<objective>
Create three path-scoped rule files in .claude/rules/ that provide strict templates for component authoring, token editing, and story writing.

Purpose: These rules activate conditionally based on what files Claude is editing, providing domain-specific patterns without polluting the context window. They are the "recipe cards" that enable autonomous component creation.

Output: Three markdown files with YAML frontmatter in .claude/rules/ directory.
</objective>

<execution_context>
@/Users/chris/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ai-integration/06-CONTEXT.md
@.planning/phases/06-ai-integration/06-RESEARCH.md

Reference these files to extract exact patterns for templates:
@packages/ui/src/components/button.tsx (simple component with CVA)
@packages/ui/src/components/tabs.tsx (compound component with Radix)
@packages/ui/src/components/tabs.figma.tsx (Figma Code Connect pattern)
@packages/ui/src/index.ts (barrel export pattern)
@packages/tokens/src/tokens/colors.json (DTCG token structure)
@packages/tokens/src/tokens/spacing.json (non-color token structure)
@packages/tokens/src/build.mjs (Style Dictionary build script)
@apps/storybook/stories/Button.stories.tsx (simple component story)
@apps/storybook/stories/Tabs.stories.tsx (compound component story)
@apps/storybook/stories/index.css (Storybook CSS with @theme)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ui-components.md rule file</name>
  <files>.claude/rules/ui-components.md</files>
  <action>
Create `.claude/rules/ui-components.md` with YAML frontmatter for path scoping. This is the most critical rule file - it must enable Claude to add a complete component autonomously.

**YAML frontmatter:**

```yaml
---
paths:
  - packages/ui/src/components/**/*.tsx
  - packages/ui/src/components/**/*.ts
  - packages/ui/src/index.ts
---
```

**Content structure:**

1. **Component Authoring Checklist** (top of file, most important)
   When creating a new component, complete ALL four steps:
   - [ ] Create component file: `packages/ui/src/components/[name].tsx`
   - [ ] Create Figma mapping: `packages/ui/src/components/[name].figma.tsx`
   - [ ] Create story: `apps/storybook/stories/[Name].stories.tsx`
   - [ ] Update barrel export: `packages/ui/src/index.ts`
         Run `pnpm typecheck` after all files are created.

2. **Simple Component Template** (exact copy-paste template)
   Show the EXACT structure from button.tsx as template:

   ```tsx
   import * as React from 'react'
   import { cva, type VariantProps } from 'class-variance-authority'
   import { cn } from '../lib/utils'

   const [name]Variants = cva(
     'base-classes',
     {
       variants: {
         variant: { default: '...', /* other variants */ },
         size: { default: '...', sm: '...', lg: '...' },
       },
       defaultVariants: {
         variant: 'default',
         size: 'default',
       },
     },
   )

   export interface [Name]Props
     extends React.HTMLAttributes<HTMLElement>,
       VariantProps<typeof [name]Variants> {}

   const [Name] = React.forwardRef<HTMLElement, [Name]Props>(
     ({ className, variant, size, ...props }, ref) => {
       return (
         <element
           ref={ref}
           className={cn([name]Variants({ variant, size, className }))}
           {...props}
         />
       )
     },
   )
   [Name].displayName = '[Name]'

   export { [Name], [name]Variants }
   ```

   Include replacement instructions for [name], [Name], HTMLElement, element.

3. **Compound Component Template** (exact copy-paste template)
   Show the EXACT structure from tabs.tsx as template:

   ```tsx
   import * as React from 'react'
   import * as [Name]Primitive from '@radix-ui/react-[name]'
   import { cn } from '../lib/utils'

   const [Name] = [Name]Primitive.Root

   const [Name]Part = React.forwardRef<
     React.ElementRef<typeof [Name]Primitive.Part>,
     React.ComponentPropsWithoutRef<typeof [Name]Primitive.Part>
   >(({ className, ...props }, ref) => (
     <[Name]Primitive.Part
       ref={ref}
       className={cn('semantic-token-classes', className)}
       {...props}
     />
   ))
   [Name]Part.displayName = [Name]Primitive.Part.displayName

   export { [Name], [Name]Part, /* all parts */ }
   ```

4. **Figma Code Connect Template** (exact copy-paste template)

   ```tsx
   import React from 'react'
   import figma from '@figma/code-connect'
   import { [Name] } from './[name]'

   figma.connect(
     [Name],
     'https://www.figma.com/design/FIGMA_FILE_KEY?node-id=NODE_ID',
     {
       props: {
         // Map Figma props to React props
       },
       example: (props) => <[Name] {...props} />,
     },
   )
   ```

5. **Barrel Export Pattern**
   Show how to add to `packages/ui/src/index.ts`:
   - Simple component: `export { [Name], [name]Variants } from './components/[name]'`
   - Compound component: Export all parts individually (never default exports)
   - Type exports: `export type { [Name]Props } from './components/[name]'`

6. **Anti-Patterns** (CRITICAL - show wrong vs right)

   **No inline styles:**

   ```tsx
   // WRONG
   <button style={{ backgroundColor: '#3b82f6' }}>Click</button>
   // CORRECT
   <button className="bg-primary">Click</button>
   ```

   Why: Inline styles bypass tokens and break dark mode. ESLint will error.

   **No arbitrary Tailwind values:**

   ```tsx
   // WRONG
   <div className="bg-[#ff0000] text-[18px] mt-[13px]">
   // CORRECT
   <div className="bg-destructive text-base mt-4">
   ```

   Why: Arbitrary values bypass semantic tokens. Use token-mapped utilities only.

   **Always forwardRef:**

   ```tsx
   // WRONG
   const Button = ({ className, ...props }) => { ... }
   // CORRECT
   const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
     ({ className, ...props }, ref) => { ... }
   )
   Button.displayName = 'Button'
   ```

   Why: Components must forward refs for composition (Radix triggers need ref access).

   **Always displayName:**

   ```tsx
   // WRONG - missing displayName
   const Button = React.forwardRef(...)
   // CORRECT
   const Button = React.forwardRef(...)
   Button.displayName = 'Button'
   ```

   Why: React DevTools and Radix debugging require displayName on forwardRef components.

   **Always cn() for className:**

   ```tsx
   // WRONG
   className={`bg-primary ${className}`}
   // CORRECT
   className={cn('bg-primary', className)}
   ```

   Why: cn() handles undefined, deduplicates, and resolves Tailwind conflicts correctly.

   **Semantic tokens only:**

   ```tsx
   // WRONG
   className = 'bg-blue-500 text-white border-gray-300'
   // CORRECT
   className = 'bg-primary text-primary-foreground border-border'
   ```

   Why: Semantic tokens enable automatic dark mode via CSS variable swapping.

Keep file under 400 lines. This is the most detailed rule file.
</action>
<verify> - File exists: `test -f .claude/rules/ui-components.md && echo "exists"` - Has YAML frontmatter with paths: `head -5 .claude/rules/ui-components.md` shows paths field - Contains templates: `grep -c "forwardRef" .claude/rules/ui-components.md` returns 3+ - Contains anti-patterns: `grep -c "WRONG" .claude/rules/ui-components.md` returns 4+ - Contains checklist: `grep "barrel export" .claude/rules/ui-components.md` returns match - Under 400 lines: `wc -l .claude/rules/ui-components.md` shows < 400
</verify>
<done>ui-components.md exists in .claude/rules/ with YAML frontmatter paths targeting packages/ui, containing component authoring checklist, simple + compound component templates, Figma mapping template, barrel export pattern, and 6+ anti-pattern examples with explanations.</done>
</task>

<task type="auto">
  <name>Task 2: Create token-authoring.md and storybook-stories.md rule files</name>
  <files>.claude/rules/token-authoring.md, .claude/rules/storybook-stories.md</files>
  <action>
Create two rule files in `.claude/rules/`.

**File 1: `.claude/rules/token-authoring.md`**

YAML frontmatter:

```yaml
---
paths:
  - packages/tokens/src/tokens/**/*.json
  - packages/tokens/src/build.mjs
---
```

Content:

1. **Token File Structure** - DTCG format with `$value`, `$type`, `$description`
   Show exact JSON structure:

   ```json
   {
     "category": {
       "name": {
         "$value": "value-here",
         "$type": "type-here",
         "$description": "Optional description"
       }
     }
   }
   ```

2. **Color Token Rules**
   - ALL colors use OKLCH format: `oklch(L C H)` where L=0-1, C=0-0.4, H=0-360
   - Light tokens in `colors.json`, dark overrides in `colors.dark.json`
   - Follow semantic naming from shadcn/ui: background, foreground, primary, secondary, muted, accent, destructive, border, input, ring
   - Scale tokens use 50-950 numbered steps

3. **Non-Color Token Rules**
   - Spacing: 8px base unit with multipliers (0.5, 1, 1.5, 2...). $type: "dimension"
   - Typography: Use rem units. $type: "fontFamily" | "fontSize" | "fontWeight" | "lineHeight"
   - Border radii: Use rem units. $type: "dimension"

4. **After Editing Tokens**
   - Run `cd packages/tokens && pnpm build` to regenerate CSS
   - Check `packages/tokens/dist/` for output files
   - If adding new semantic tokens, update `apps/web/src/index.css` AND `apps/storybook/stories/index.css` @theme section
   - Both CSS files must stay in sync

5. **Anti-Patterns**
   - No hex colors: Use OKLCH format exclusively
   - No px in spacing $value: Use raw numbers, CSS transform adds px
   - No hardcoded values in components: Always reference tokens via Tailwind utilities
   - No editing dist/ files: Always edit source JSON, then build

Keep file under 200 lines.

**File 2: `.claude/rules/storybook-stories.md`**

YAML frontmatter:

```yaml
---
paths:
  - apps/storybook/stories/**/*.stories.tsx
  - apps/storybook/stories/**/*.mdx
---
```

Content:

1. **Story File Template** (exact copy-paste)

   ```tsx
   import type { Meta, StoryObj } from '@storybook/react'
   import { [Name] } from '@phoenix/ui'

   const meta = {
     title: 'Components/[Name]',
     component: [Name],
     tags: ['autodocs'],
     parameters: {
       layout: 'centered',  // or 'padded' for full-width components
     },
     argTypes: {
       // Map props to Storybook controls
     },
   } satisfies Meta<typeof [Name]>

   export default meta
   type Story = StoryObj<typeof meta>

   export const Default: Story = {
     args: {
       // Default prop values
     },
   }
   ```

2. **Compound Component Stories**
   - Add `subcomponents` property to meta for compound components
   - Use `render` function instead of `args` when composition is needed
   - Import all parts from @phoenix/ui

3. **Story Naming Conventions**
   - Default: Base component with default props
   - AllVariants: Shows all variant options side by side
   - WithDisabled: Disabled state
   - [SpecificFeature]: Feature-specific stories (e.g., WithAutoResize)

4. **Anti-Patterns**
   - No `satisfies Meta<any>`: Always use `satisfies Meta<typeof [Component]>`
   - No missing `tags: ['autodocs']`: Required for automatic prop table generation
   - No hardcoded hex values in stories: Use semantic token classes
   - No default exports for stories (only for meta): Named exports only (`export const Default`)

Keep file under 150 lines.
</action>
<verify> - Token rule exists: `test -f .claude/rules/token-authoring.md && echo "exists"` - Story rule exists: `test -f .claude/rules/storybook-stories.md && echo "exists"` - Token rule has paths: `head -5 .claude/rules/token-authoring.md` shows paths - Story rule has paths: `head -5 .claude/rules/storybook-stories.md` shows paths - Token rule contains OKLCH: `grep "OKLCH\|oklch" .claude/rules/token-authoring.md` returns matches - Story rule contains template: `grep "satisfies Meta" .claude/rules/storybook-stories.md` returns match - Token rule under 200 lines: `wc -l .claude/rules/token-authoring.md` shows < 200 - Story rule under 150 lines: `wc -l .claude/rules/storybook-stories.md` shows < 150
</verify>
<done>token-authoring.md and storybook-stories.md exist in .claude/rules/ with correct YAML frontmatter paths, containing exact templates, token format rules, OKLCH color constraints, story CSF 3.0 template, and anti-patterns for each domain.</done>
</task>

</tasks>

<verification>
1. All three rule files exist: `ls .claude/rules/`
2. All have YAML frontmatter: `head -5 .claude/rules/*.md`
3. ui-components.md targets packages/ui: `grep "packages/ui" .claude/rules/ui-components.md`
4. token-authoring.md targets packages/tokens: `grep "packages/tokens" .claude/rules/token-authoring.md`
5. storybook-stories.md targets apps/storybook: `grep "apps/storybook" .claude/rules/storybook-stories.md`
6. All contain anti-patterns: `grep -l "WRONG\|Anti" .claude/rules/*.md`
7. `pnpm typecheck` passes (no TypeScript files modified, but verify repo integrity)
</verification>

<success_criteria>

- Three rule files exist in .claude/rules/ with correct YAML frontmatter paths
- ui-components.md provides complete component lifecycle template (component + figma + story + barrel)
- token-authoring.md provides DTCG format rules, OKLCH constraints, and build workflow
- storybook-stories.md provides CSF 3.0 story template with autodocs
- All files include anti-pattern documentation with WRONG/CORRECT comparisons
- Line counts: ui-components < 400, token-authoring < 200, storybook-stories < 150
- Requirements AIML-02, AIML-03, AIML-04 satisfied
  </success_criteria>

<output>
After completion, create `.planning/phases/06-ai-integration/06-02-SUMMARY.md`
</output>
